# 浏览器扩展设计文档

## 脚本的安装

安装功能由网站端、扩展端、服务器端协同完成，流程如下：
1. 用户在平台网站找到需要的脚本并点击安装。
2. 网站页面向扩展接口发送一条消息，消息内容包含预安装的脚本ID 和 accessToken。 （消息发送可通过postMessage API 或者自定义的 DOM event）
3. 扩展接口收到消息后，向用户弹窗确认是否安装。
4. 扩展后台根据脚本ID从服务器下载脚本代码，请求时携带 accessToken 用于身份验证。
5. 扩展后台利用 storage API 将脚本代码储存到浏览器中。 （后续可考虑改用 IndexedDB）
6. 脚本安装完成后默认为启用状态，随时等待执行。

## 脚本的执行

### 执行流程

1. 扩展后台监听浏览器的页面加载事件。
2. 当有新的页面加载时，扩展根据新页面的 URL 匹配待执行的脚本，匹配规则可参考 Web extension 中的 match patterns。
3. 扩展将匹配到的脚本按顺序注入目标页面，注入后脚本及开始执行。 （注入脚本可使用 tabs.executeScript API）

### 多脚本的执行顺序

- 若有多个脚本适用于同一页面，默认将按照安装的顺序执行。
- 不同脚本间不建议存在先后依赖关系。

### 脚本的运行环境

- 注入的脚本将在一个独立的上下文中运行，与目标页面的 JS 环境隔离。
- 脚本和目标页面共享同一个 DOM，以便于脚本修改目标页面的元素的无障碍属性。
- 同一页面的所有脚本都在同一个上下文中运行，若无必要应避免修改全局的对象，以免影响其他脚本。
- 详细内容可参考 [content_script_environment](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Content_scripts#content_script_environment)。

## 脚本的管理

- 在 popup 页面显示当前网站可用的脚本，切换脚本的启用/禁用状态。
- 在 option 页面提供已安装脚本的管理功能，包括启用/禁用，查看/编辑代码，删除脚本、手动/自动更新脚本。
- TODO: 详细设计待完善


## 脚本的格式

无障碍优化脚本由普通的 JS 语言编写，在脚本头部以固定的注释格式定义脚本的元数据。

元数据部分包含多个字段，包括 name, description, match 等，具体描述可参考 [Tampermonkey 的文档](https://www.tampermonkey.net/documentation.php?locale=en)。

## 其他说明

### 关于扩展版本的选择问题

目前 Web extension manifest 的最新版本是 V3， V3 在扩展安全性方面做了更多的限制，例如禁止在扩展环境中执行动态的字符串代码，这一限制将直接影响脚本注入功能的实现方式。

若基于 V3 开发此扩展，我们可能需要将脚本的注入执行功能放在页面上下文中实现，这将无法利用扩展原生提供的隔离环境和相关的 API，我们需要自己解决 sandbox 机制以及页面和扩展间的数据交换等问题。

使用 V2 也存在一些问题：从2022年开始，Chrome 和Edge 等浏览器的扩展商店已经不能上传 V2 版本的新扩展，各浏览器也将在未来的版本中停止支持 V2，详见 [Chrome Extensions Manifest V2 support timeline - Chrome Developers](https://developer.chrome.com/docs/extensions/migrating/mv2-sunset/)。

综合考虑，我们可暂时使用 V2 版本，后续再逐渐迁移到 V3。

### 关于浏览器扩展的替代方案

调研发现，目前市面上的两个扩展： Tampermonkey 和 Violentmonkey，已经能够满足我们在脚本执行和管理方面的需求。并且，这两个扩展也支持从第三方网站安装脚本，我们只需要做一些简单的调整就能适配它们。

不过，测试发现，这两个扩展在可访问性和易用性方面还存在一些不足之处，对于电脑经验较少的视障用户可能不太友好。

综合考虑，我们可以先尝试开发自己的扩展，以实现一些自定义的需求。若发现开发时间紧张，也可先用已有的扩展替代。同时，我们需要在脚本格式方面尽量遵循现有的规范，以方便可能的扩展替换。
